<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: bindings.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: bindings.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * the main NameSpace for bindings.js
 *
 * @namespace bindings
 */
bindings = {
	bindings: {},

	/**
	 * Creates a new {@link bindings.Modal} based on an Object
	 *
	 * @param {Object} Object - The Object that the {@link bindings.Modal} will use.
	 * @param {Object} Options - An Object that contains options.
	 */
	createModal: function(object,options){
		var modal = new this.Modal(object,options);
		object._binding = modal;

		return object;
	},

	/**
	 * Binds a {@link bindings.Modal} to a dom element.
	 * 
	 * @param {bindings.Modal} Modal - The Modal to bind.
	 * @param {Node} Element - The Element to bind to.
	 */
	applyBindings: function(modal,el){
		modal = modal || {};
		if(modal instanceof this.Modal){
			modal.applyBindings(el)
		}
		else if(modal._binding instanceof this.Modal){
			modal._binding.applyBindings(el)
		}
	},

	_applyBindings: function(el,scope){
		if(!(el instanceof Node)) throw new Error('first argument has to be a Node');
		if(!(scope instanceof bindings.Scope) &amp;&amp; !(scope instanceof bindings.Value)) throw new Error('second argument has to be a Scope or a Value');
		var _bindings = [];

		//remove old bindings
		if(el.__bindings__){
			for (var i = el.__bindings__.length - 1; i >= 0; i--) {
				el.__bindings__[i]._unbind();
			};
			el.__bindings__ = [];
		}
		var data = bindings._parseBindings(el,scope);
		el.__bindings__ = data;

		_bindings = _bindings.concat(el.__bindings__);

		//loop through and bind children
		if(el.children){
			for (var i = 0; i &lt; el.children.length; i++) {
				el.children[i].__scope__ = el.children[i].__scope__ || scope;
				bindings._applyBindings(el.children[i],el.children[i].__scope__);
				_bindings = _bindings.concat(el.children[i].__bindings__);
			};
		}

		return _bindings;
	},
	_parseBindings: function(el,scope){ //parses bindings for a specific element 
		if(!(el instanceof Node)) throw new Error('first argument has to be a Node');
		if(!(scope instanceof bindings.Scope) &amp;&amp; !(scope instanceof bindings.Value)) throw new Error('second argument has to be a Scope or a Value');

		var _bindings = [];
		var attrs = el.attributes || [];
		for (var i = 0; i &lt; attrs.length; i++) {
			var attr = attrs.item(i);
			var id = attr.name;
			//find the binding attrs and extract the src
			if(id.search('bind-') !== -1){
				id = id.substr(id.indexOf('-')+1,id.length);
				var src = attr.value;
				var binding = new bindings.Binding(el,src,scope,id);
				_bindings.push(binding);
			}
		};
		return _bindings;
	},
	_modalChange: function(scope,data){ //handles events from the modal object changing
		for (var i = 0; i &lt; data.length; i++) {
			if(data[i].name == '_binding') continue;

			switch(data[i].type){
				case 'add':
					scope.setKey(data[i].name,data[i].object[data[i].name],true);
					break;
				case 'update':
					scope.setKey(data[i].name,data[i].object[data[i].name],true);
					break;
				case 'delete':
					scope.removeKey(data[i].name,true);
					break;
			}
		};
		scope.update();
	},
	_nodeChange: function(event){ //handles events for dom changes
		event.stopPropagation();

		var scope = event.target.__scope__ || event.relatedNode.__scope__;
		if(scope){
			bindings._applyBindings(event.target,scope);
		}
	},
	_eval: function(string,scope){
		if(!(scope instanceof bindings.Scope) &amp;&amp; !(scope instanceof bindings.Value)) throw new Error('second argument has to be a Scope or a Value');

		string = string || '';
		var data = {
			value: undefined,
			success: true,
		}

		var func = 'new Function("', args = [];
		var context = scope.value;

		func += 'with(this){';
		func += 'return ';
		func += string;
		func += '}';
		func += '")';
		func = eval(func);

		try{
			data.value = func.apply(context,args);
		}
		catch(e){
			data.success = false;
		}

		return data;
	},
	_evalRequires: function(string,scope){ //only binds to values/scopes on the first level
		if(!(scope instanceof bindings.Scope) &amp;&amp; !(scope instanceof bindings.Value)) throw new Error('second argument has to be a Scope or a Value');

		string = string || '';
		var data = {
			success: true,
			requires: [], //all values in this src
			sets: [], //array of values set
			gets: [] //array of values got
		}
		var scopeVars = {
			console: {},
			window: {},
			navigator:{},
			localStorage: {},
			location: {},
			alert: bindings.noop,
			eval: bindings.noop
		}

		//compile scope
		var buildContextFromScope = function(s){
			var o = new s.values.__proto__.constructor;
			for (var i in s.values) {
				o.__defineGetter__(i,function(o,i,data){
					data.requires.push(this.values[i]);
					data.gets.push(this.values[i]);

					if(typeof this.values[i].value !== 'function'){
						if(this.values[i] instanceof bindings.Scope){
							return buildContextFromScope(this.values[i]);;
						}
						else{
							return this.values[i].value;
						}
					}
				}.bind(s,o,i,data))

				o.__defineSetter__(i,function(o,i,data,val){
					data.requires.push(this.values[i]);
					data.sets.push(this.values[i]);
					
					// this.values[i].setValue(val);
					// o[i] = val;
				}.bind(s,o,i,data))
			};
			return o;
		}

		var func = 'new Function(', args = [];
		var context = {};

		//add scopeVars
		for (var i in scopeVars) {
			func += '"' + i + '",';
			args.push(scopeVars[i])
		};
		if(scope instanceof bindings.Scope){
			context = buildContextFromScope(scope);

			//reset gets &amp; sets
			data.gets = [];
			data.sets = [];
			data.requires = [];
		}
		else if(scope instanceof bindings.Value){ //NOTE going to have to test/fix this for using values as a ctx for eval
			context = scope.value;
		}

		func += '"with(this){';
		func += 'return ';
		func += string;
		func += '}';
		func += '")';
		func = eval(func);

		try{
			func.apply(context,args);
		}
		catch(e){
			data.success = false;
		}

		//remove duplicates
		var d = [];
		for (var i = 0; i &lt; data.requires.length; i++) {
			if(d.indexOf(data.requires[i]) == -1) d.push(data.requires[i]);
		};
		data.requires = d;

		return data;
	},
	_evalOnScope: function(){ //just like _eval but returns a scope or value, best used with simple expresion like { this.someValue }, this works { this.someValue + 'string' } but is not recomended as it will return only the first value that is gotten
		var data = {
			value: undefined,
			success: false
		}
		var _data = bindings._evalRequires.apply(this,arguments);
		data.value = _data.gets[_data.gets.length-1];
		data.success = !!data.value;
		return data;
	},
	_duplicateObject: function(obj2,count){
		if(typeof obj2 == 'object' &amp;&amp; obj2 !== null){
			count = (count !== undefined)? count : 20;
			if(count > 0){
				// see if its an array
				if(obj2.hasOwnProperty('length')){
					var obj = []
					for (var i = 0; i &lt; obj2.length; i++) {
						if(typeof obj2[i] !== 'object'){
							obj[i] = obj2[i]
						}
						else{
							obj[i] = bindings._duplicateObject(obj2[i],count-1)
						}
					};
				}
				else{
					var obj = {}
					for (var i in obj2){
						if(typeof obj2[i] !== 'object'){
							obj[i] = obj2[i]
						}
						else{
							obj[i] = bindings._duplicateObject(obj2[i],count-1)
						}
					}
				}
			}
			return obj;
		}
		else{
			return obj2
		}
	},
	noop: function(){}
}

//fix for IE
if(!document.children){
	document.__defineGetter__('children',function(){
		return this.body.children;
	})
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="bindings.Binding.html">Binding</a></li><li><a href="bindings.Modal.html">Modal</a></li><li><a href="bindings.Scope.html">Scope</a></li><li><a href="bindings.Script.html">Script</a></li><li><a href="bindings.Value.html">Value</a></li></ul><h3>Namespaces</h3><ul><li><a href="bindings.html">bindings</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a> on Sun Jun 07 2015 13:59:50 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
